return this.list([
    {
      title: 'scaffold: collection - users',
      task: () =>
        this.steps(async (obs) => {
          obs.next('querying...')
          return this.query(
            this.scaffold.collection('users', {
              history_days: null,
              ttl_days: null
            })
          )
            .then(() => {
              obs.next('results received!')
              obs.complete()
            })
            .catch((err) => {
              obs.next('encountered an error!')
              return this.delay(500).then(() => {
                obs.error({
                  message: err.message
                })
              })
            })
        })
    },
    {
      title: 'scaffold: collection - actions',
      task: () => true
    }
  ])

   // fqlQueryOrWrappedFQL
      // console.log('fqlQueryOrWrappedFQL', JSON.stringify(fqlQueryOrWrappedFQL, null, 2))
      // const processArray = (arr: []) => {
      //   return arr.map((item) => {
      //     if (Array.isArray(item)) {
      //       return processArray(item)
      //     } else if (typeof item === 'object') {
      //       return processObject(item)
      //     } else {
      //       return item
      //     }
      //   })
      // }

      // const processObject = (obj: object) => {
      //   let symbols = Object.getOwnPropertySymbols(obj).map((a) => a.toString())
      //   let hasFQLWrapper = symbols.includes('Symbol(FQLWrapper)')
      //   let hasDBCollection = symbols.includes('Symbol(DBCollection)')
      //   if (hasFQLWrapper) {
      //     return procede((obj as DBFqlWrapper).fql)
      //   } else if (hasDBCollection) {
      //     try {
      //       return procede((obj as DBCollection).list().fql)
      //     } catch (error) {
      //       console.error(error)
      //     }
      //   } else {
      //     return resolve(obj)
      //   }
      // }

      // const resolve = (obj: object) =>
      //   Object.entries(obj).reduce((resolved, [key, value]) => {
      //     if (Array.isArray(value)) {
      //       resolved[key] = processArray(value as [])
      //     } else if (value && typeof value === 'object') {
      //       resolved[key] = processObject(value as object)
      //     } else {
      //       resolved[key] = value
      //     }
      //     return resolved
      //   }, {})

      // const procede = (value: any) => {
      //   if (Array.isArray(value)) {
      //     return processArray(value as [])
      //   } else if (typeof value === 'object') {
      //     return processObject(value as object)
      //   } else {
      //     return value
      //   }
      // }

      // let symbols = Object.getOwnPropertySymbols({ root: fqlQueryOrWrappedFQL }).map((a) => a.toString())
      // let hasFQLWrapper = symbols.includes('Symbol(FQLWrapper)')

      // console.log('resolvedQuery', JSON.stringify(fqlQueryOrWrappedFQL, null, 2))
      // let fqlQuery = hasFQLWrapper ? (fqlQueryOrWrappedFQL as DBFqlWrapper).fql : fqlQueryOrWrappedFQL
      // let resolvedQuery = procede(fqlQueryOrWrappedFQL)
      // console.log('resolvedQuery', JSON.stringify(resolvedQuery, null, 2))
      // return this.client.query(new Expr(fqlQuery))

      
    // this.wrap = function wrap(fqlQuery: Expr, options?: DBFqlWrapperOptions): DBFqlWrapper {
    //   const { then = (res: any) => res } = options || {}
    //   const self = this
    //   return {
    //     [Symbol('FQLWrapper')]: true,
    //     then,
    //     fql: fqlQuery
    //     // query: function() {
    //     //   return self.client.query(fqlQuery)
    //     // }
    //   }
    // }